-- This file was written by David Darais ("DD"), with the help of
-- Joshua Dunfield and Matthew Hammer.  It consists of a formalization
-- of Incremental Computation with Names via an experimental, affine
-- type system that we've since abandoned.

-- Next steps: Instead of using this affine type system, we should use
-- the (much simpler) one from OOPSLA 2015.  The operational semantics
-- is largely missing from this file, and we should encode the one
-- from the OOPSLA 2015 paper.

-- - - - - - - - - - - - - - - - - - -

-- DD's questions:
-- + why do we need Can + Did, why not use Can and use its absence as
--   Did?
--
--    Suppose you evaluate
--
--       let x ← ref(name k,…) in
--        let y ← get(x) in
--         get(y).
--
--    This is supposed to be forbidden; x is used linearly, and y is used linearly,
--    but they refer to the same underlying reference cell.
--
--    With Did, this is forbidden, because the Did resource (in the Δ' generated by the conjecture
--    while evaluating ref(name k,…)) can't be given to both get(x) and get(y).
--    (At least, this is the intent of the well-formedness stuff "… actx" in the conjecture.)
--
--    If we interpret "the absence of Can as Did", then we don't know whether some other expression
--    in the larger context will access the same ref cell.
--

data Name : Set where
  ∙ : Name
  left : Name → Name
  right : Name → Name

data Pointer : Set where
  ptr : Name → Pointer

mutual
  data Vtype : Set where
    name : Name → Vtype
    tensor : Vtype → Vtype → Vtype
    thunk : Ctype → Vtype
    ref : Vtype → Vtype

  data Ctype : Set where
    _⇒_ : Vtype → Ctype → Ctype
    f : Vtype → Ctype

-- for Γ
data premise : Set where
  CType : Pointer → Ctype → premise
  vtype : Pointer → Vtype → premise
data context : Set where
  ∙ : context
  _∷_ : premise → context → context

data _,_ΓC∈_ : Pointer → Ctype → context → Set where
  Z : ∀ Γ τ p → (p , τ ΓC∈ (CType p τ ∷ Γ))
  S : ∀ Γ r τ p → (p , τ ΓC∈ Γ) → (p , τ ΓC∈ (r ∷ Γ))

data _,_ΓV∈_ : Pointer → Vtype → context → Set where
  Z : ∀ Γ τ p → (p , τ ΓV∈ (vtype p τ ∷ Γ))
  S : ∀ Γ r τ p → (p , τ ΓV∈ Γ) → (p , τ ΓV∈ (r ∷ Γ))

data _,_V⊢_ : context → dcontext → Vtype → Set where
  Var : ∀ Γ Δ τ → (τ D∈ Δ) → (Γ , Δ V⊢ τ)
  tensor : ∀ Γ Δ₁ Δ₂ τ₁ τ₂ → (Γ , Δ₁ V⊢ τ₁) → (Γ , Δ₂ V⊢ τ₂) → (Γ , (Δ₁ +D+ Δ₂) V⊢ (tensor τ₁ τ₂))
  name : ∀ Γ Δ k → (Γ , Can k ∷ Δ V⊢ name k)
  thunk : ∀ Γ Δ τ k → (ptr k , τ ΓC∈ Γ) → (Γ , Did k ∷ Δ V⊢ thunk τ)
  ref : ∀ Γ Δ τ k → (ptr k , τ ΓV∈ Γ) → (Γ , Did k ∷ Δ V⊢ ref τ)

data _,_C⊢_ : context → dcontext → Ctype → Set where
  Ret : ∀ Γ Δ τ → (Γ , Δ V⊢ τ) → (Γ , Δ C⊢ f τ)
  Lam : ∀ Γ Δ (τ₁ : Vtype) (τ₂ : Ctype) → (Γ , Type τ₁ ∷ Δ C⊢ τ₂) → (Γ , Δ C⊢ (τ₁ ⇒ τ₂))
  App : ∀ Γ Δ₁ Δ₂ τ₁ τ₂ → (Γ , Δ₁ C⊢ (τ₁ ⇒ τ₂)) → (Γ , Δ₂ V⊢ τ₁) → (Γ , (Δ₁ +D+ Δ₂) C⊢ τ₂)
  Fork : ∀ Γ Δ (k : Name) → (Γ , Δ V⊢ name k) → (Γ , Δ C⊢ f (tensor (name (left k)) (name (right k))))
  thunk : ∀ Γ Δ₁ Δ₂ τ k → (Γ , Δ₁ V⊢ name k) → (Γ , Δ₂ C⊢ τ) → (Γ , (Δ₁ +D+ Δ₂) C⊢ f (thunk τ))
  ref : ∀ Γ Δ₁ Δ₂ τ k → (Γ , Δ₁ V⊢ name k) → (Γ , Δ₂ V⊢ τ) → (Γ , (Δ₁ +D+ Δ₂) C⊢ f (ref τ))
  Get : ∀ Γ Δ τ → (Γ , Δ V⊢ ref τ) → (Γ , Δ C⊢ f τ)
  Split : ∀ Γ Δ₁ Δ₂ (τ₁ τ₂ : Vtype) (τ₃ : Ctype) → (Γ , Δ₁ V⊢ tensor τ₁ τ₂) → (Γ , Type τ₁ ∷ Type τ₂ ∷ Δ₂ C⊢ τ₃) → (Γ , (Δ₁ +D+ Δ₂) C⊢ τ₃)

data terminal : ∀ Γ Δ C -> Γ , Δ C⊢ C -> Set where
   Lam : ∀ Γ Δ A C → (e : Γ , Type A ∷ Δ C⊢ C) -> terminal Γ Δ (A ⇒ C) (Lam Γ Δ A C e)
   Ret : ∀ Γ Δ A   → (v : Γ , Δ V⊢ A)          -> terminal Γ Δ (f A)   (Ret Γ Δ A   v)

-- Question: In the formal syntax, we distinguish terminal expressions
-- from non-terminal ones, making terminals a special sub-class of
-- non-terminal expressions.  Can we express that relationship here?
-- How do we, for instance, write the type of a terminal expression
-- such that a non-terminal expression will have a distinct, less
-- specific (more general) type.  Do we use subtyping of some kind?
-- Or, perhaps we just want a predicate over things of type (Γ , Δ C⊢ C) ?
-- Tried to do this above, but I'm getting it wrong somehow.

-- digressions
-- data _⊢_;_  :  context → term → type → Set
-- (Γ ⊢ e : τ)
-- Intersect : ∀ Γ Δ τ₁ τ₂ (e₁ : Γ , Δ ⊢ τ₁) (e₂ : Γ , Δ ⊢ τ₂) → (strip e₁ ~ strip e₂) → Γ , Δ ⊢ (τ₁ /\ τ₂)

data action : Set where
  Allocref : ∀ Γ Δ (A : Vtype) -> (Γ , Δ V⊢ A) -> action
  AllocThk : ∀ Γ Δ (C : Ctype) -> (Γ , Δ C⊢ C) -> action
  Obsref : ∀ Γ Δ (A : Vtype) -> (Γ , Δ V⊢ A) -> action
  ObsThk : ∀ Γ Δ (C : Ctype) -> (Γ , Δ C⊢ C) -> action

data dirtybit : Set where
  Dirty : dirtybit
  Clean : dirtybit

data edge : Set where
  Edge : Pointer -> action -> dirtybit -> Pointer -> edge

data graph : Set where
  Emp : graph
  ref : ∀ Γ Δ (A : Vtype) -> graph -> Pointer -> (Γ , Δ V⊢ A) -> graph
  Thk : ∀ Γ Δ (C : Ctype) -> graph -> Pointer -> (Γ , Δ C⊢ C) -> graph
  Res : ∀ Γ Δ (C : Ctype) -> graph -> Pointer -> (Γ , Δ C⊢ C) -> (Γ , Δ C⊢ C) -> graph
  Edge : graph -> edge -> graph

-- Operational semantics (Figure 8, on page 19)

-- Hammer: STUCK:
-- DD: I don't think you need this...
-- terminal_exp : ∀ Γ Δ C -> (terminal Γ Δ C (Γ , Δ C⊢ C)) -> (Γ , Δ C⊢ C)
-- terminal_exp (Lam Γ Δ C e) = e
-- terminal_exp (Ret Γ Δ C e) = e

data _,_,_⇓_,_ {Γ Δ C} : graph -> Pointer -> (Γ , Δ C⊢ C) -> graph -> (Γ , Δ C⊢ C) -> Set where
  Term : ∀ (G : graph) (p : Pointer) (e : Γ , Δ C⊢ C) -> terminal Γ Δ C e -> ( G , p , e ⇓ G , e )
